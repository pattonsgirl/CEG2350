## 02 - Bash

- File manipulation
- Scripting
- Path & environment variables
- Regular Expressions
- grep, sed, awk

### PATH & environment variables

**Core Commands:**
- `which`
- `whereis`
- `env`

### File manipulation

**Core Commands**
- `sort`
- `cut`
- `wc`
- `paste`
- `join`
- `head` / `tail`
- `less` / `more`
- Streams - standard input, standard output, and standard error (2)
- `>` vs `>>` vs `>>>`
- `<`
- `|`
- doubles quotes `"`, single quotes `'`, and backticks \`

#### Functional Control

In Bash, quoting is less about "style" and more about **functional control**. Choosing the wrong quote can be the difference between printing a variable's value and printing the literal name of the variable.

---

#### 1. Single Quotes (`' '`): The Literal String

Single quotes are the "hands-off" option. They preserve the **literal value** of every character within the quotes. Bash will not interpret variables, backslashes, or commands.

* **Use case:** When you want exactly what you typed, no exceptions.

```bash
NAME="Gemini"
echo 'Hello $NAME' 
# Output: Hello $NAME

```

> **Note:** You cannot put a single quote inside single quotes, even with a backslash.

---

#### 2. Double Quotes (`" "`): The Interpretive String

Double quotes are "flexible." They protect the string from being split by spaces (word splitting), but they still allow the shell to interpret specific special characters like `$`, ```, and `\`.

* **Use case:** When you want to include variables or command results within a string.

```bash
NAME="Gemini"
echo "Hello $NAME"
# Output: Hello Gemini

```

##### The Difference in Action:

| Feature | Single Quotes (`'`) | Double Quotes (`"`) |
| --- | --- | --- |
| **Variable Expansion (`$VAR`)** | No (Literal) | **Yes** |
| **Command Substitution** | No (Literal) | **Yes** |
| **Backslash Escapes** | No (Literal) | **Yes** |

---

#### 3. Backticks (`` ``): The Command Substitution

Backticks are used to execute a command and capture its output into a variable or another string.

* **Modern Alternative:** While backticks still work, the modern standard is `$(command)`. It is preferred because it is easier to nest (put a command inside a command).

```bash
# Using Backticks
CURRENT_DIR=`pwd`

# Using Modern Syntax (Recommended)
CURRENT_DIR=$(pwd)

echo "You are currently in: $CURRENT_DIR"

```

---

#### The "Final Boss" Demo

Here is a single script that demonstrates how these three interact:

```bash
USER_COUNT=$(who | wc -l) # Command substitution

# 1. Double Quotes: Expands the variable
echo "There are $USER_COUNT users logged in."
# Output: There are 3 users logged in.

# 2. Single Quotes: Treats everything as text
echo 'The variable is written as $USER_COUNT'
# Output: The variable is written as $USER_COUNT

# 3. Mixing them: Using backticks inside double quotes
echo "Today is `date`"
# Output: Today is Tue Jan 27 13:21:19 EST 2026

```

**Why does this matter?**

If you have a filename with a space, like `My Resume.pdf`, and you try to run `ls $FILE` without double quotes, Bash will look for two files: `My` and `Resume.pdf`. Using `ls "$FILE"` ensures Bash treats it as one single item.

### Regular Expressions

A regular expression (regex for short) allow developers to match strings against a pattern, extract submatch information, or simply test if the string conforms to that pattern.

> Usually such patterns are used by string-searching algorithms for "find" or "find and replace" operations on strings, or for input validation. - [Wiki](https://en.wikipedia.org/wiki/Regular_expression)

Frequently used regex (tables generated by Gemini)

---

#### ðŸš© The Basics: Characters & Anchors

| Symbol | Description | Example |
| --- | --- | --- |
| `.` | **Wildcard**: Matches any single character except newline. | `b.t` matches `bat`, `bet`, `bit`. |
| `^` | **Start**: Matches the beginning of a line. | `^Hello` matches "Hello world". |
| `$` | **End**: Matches the end of a line. | `bye$` matches "See ya, bye". |
| `\` | **Escape**: Lets you search for special characters like `.` or `*`. | `\.com` matches ".com". |
| ` \| ` | **OR**: Matches the pattern on the left or the right. |

---

#### ðŸ”¢ Quantifiers: "How many?"

* `*` : **0 or more** (The "greedy" one).
* `+` : **1 or more** (At least one must exist).
* `?` : **0 or 1** (Makes the character optional).
* `{n}` : **Exactly n** times (e.g., `\d{3}` matches 3 digits).
* `{n,m}` : **Between n and m** times.

---

#### ðŸ“¦ Character Classes & Shorthand

| Shorthand | Meaning | Equivalent To |
| --- | --- | --- |
| `\d` | Any **Digit** | `[0-9]` |
| `\D` | Any **Non-digit** | `[^0-9]` |
| `\w` | Any **Word character** | `[a-zA-Z0-9_]` |
| `\W` | Any **Non-word character** | (symbols, spaces, etc.) |
| `\s` | Any **Whitespace** | (space, tab, newline) |
| `[abc]` | **Set**: Matches any char in brackets | `a`, `b`, or `c` |
| `[^abc]` | **Negated Set**: Matches anything *except*... | Everything but `a`, `b`, or `c` |

---

**Frequently Used Resources**
- [Regex One - Learning Tutorial](https://regexone.com/)
- [Regex 101 - Expression Generator & Validation Testing](https://regex101.com/)

**Games**
- [Regex Crossword](https://regexcrossword.com/)
- [Regex Golf](https://alf.nu/RegexGolf?world=regex&level=r00)
- [Regexle - REgex Hexagon Puzzles](https://regexle.com/)

**Examples**
- [Wordle in bash by huytd](https://gist.github.com/huytd/6a1a6a7b34a0d0abcac00b47e3d01513)

### Grep, sed, and awk

### Scripting

#### 1. Shebang

Every Bash script should start with a Shebang. This tells the system which interpreter to use.

shebang is the combination of the `#` (pound key) and `!` (exclamation
mark)â€‹

When it is the first two bytes of an executable (`x` mode) file, is
interpreted by the `execve`(2) system call (which executes programs)â€‹

- `#!/bin/sh`
    â€“ Execute the file using the Bourne shell, or a compatible shell,
assumed to be in the /bin directoryâ€‹
- `#!/bin/bash`
    â€“ Execute the file using the Bash shellâ€‹
- `#!/usr/bin/pwsh`
    â€“ Execute the file using PowerShellâ€‹
- `#!/usr/bin/env python3`
    â€“ Execute with a Python interpreter, using the
env program search path to find itâ€‹

---

#### 2. Variables

No spaces around the = sign!

- Correct: `CITY="Dayton"`
- Wrong: `CITY = "Dayton"`

**Quote your variables:** Use `"$VAR"` instead of `$VAR` to prevent errors if the variable contains spaces.

**Accessing variables:** Use the `$` sign: `echo $NAME`.

**Arguments:** These are inputs passed when you run the script (e.g., `./script.sh hello 123`).

| Variable | Description |
| --- | --- |
| `$0` | The name of the script itself |
| `$1` to `$9` | The first through ninth arguments |
| `$#` | The number of arguments passed |
| `$@` | All arguments as a single list |

---

#### 3. Conditionals and `test`

The `if` statement uses the `test` command (often written as `[ ]`) to evaluate expressions.

It is increasingly common for devs to default to the extended `test` command (often written as `[[ ]]`)

**Pro-tip:** Always put spaces inside the brackets: `[ $A == $B ]`. The brackets are representing the `test` command, which is using the values in the brackets as space separated arguments. 

**Common `test` Operators:**

* **Strings:** `==` (equal), `!=` (not equal), `-z` (is empty).
* **Numbers:** `-eq` (equal), `-ne` (not equal), `-gt` (greater than), `-lt` (less than).
* **Files:** `-f` (is a file), `-d` (is a directory).

If/Else Syntax:

```bash
if [ "$1" -gt 10 ]; then
  echo "That's a big number."
elif [ "$1" -eq 10 ]; then
  echo "Exactly ten."
else
  echo "Too small."
fi

```

---

#### 4. Loops: For and While

Loops allow you to iterate over lists of data or run commands until a condition is met.

For Loop (Iterating over a list):

```bash
for ITEM in Apple Banana Cherry; do
  echo "I like $ITEMs"
done

```

While Loop (Running until a condition changes):

```bash
COUNT=1
while [ $COUNT -le 3 ]; do
  echo "Count is $COUNT"
  ((COUNT++))
done

```

---

#### 5. Functions

Functions keep your code "DRY" (Don't Repeat Yourself). They don't take formal parameters in the parentheses; instead, they use the same `$1`, `$2` logic as the main script.

```bash
greet_user() {
  echo "Hello, $1! You are looking at the $2 directory."
}

# Calling the function
greet_user "Admin" "/home/user"

```

---

#### 6. Exit codes

**Exit Codes:** Scripts return `0` for success and non-zero for failure. You can manually set this with `exit 1`.

#### 7. Comments

**Comments:** Use `#` to explain *why* you're doing something, not just *what* the code does.
